#include <WiFi.h>
#include <WebServer.h>
#include <SPIFFS.h>
#include <esp_now.h>
#include <esp_wifi.h>
#include <SPI.h>
#include <MFRC522.h>
#include <vector>

/* =======================
   WiFi / AP configuration
   ======================= */
constexpr const char* AP_SSID    = "Smart Tray Uploader ";
constexpr const char* AP_PWD     = "";
constexpr int         AP_CHANNEL = 1;

/* =======================
   NFC (RC522) configuration
   ======================= */
constexpr int RST_PIN = 22;
constexpr int SS_PIN  = 5;
MFRC522 mfrc522(SS_PIN, RST_PIN);

/* =======================
   Hardware I/O
   ======================= */
constexpr int BUZZER_PIN = 15;

/* =======================
   Web server
   ======================= */
WebServer server(80);

/* =======================
   SPIFFS file paths
   ======================= */
constexpr const char* CSV_PATH     = "/uploaded.csv";
constexpr const char* MAPPING_PATH = "/mappings.txt";

/* =======================
   Limits
   ======================= */
constexpr size_t MAX_ITEMS = 4000;
constexpr int    MAX_PEERS = 5;

/* =========================================================
   Parsed CSV row
   Note:
   - Column 0 (Patient name) is ignored on purpose
   - We only transmit meal + identification data
   ========================================================= */
struct PatientRow {
  String nric;
  String bedWard;
  String starch;
  String veg;
  String meat;
  String fruit;
  String drink;
  String remarks;
};

std::vector<PatientRow> patients;
std::vector<String>     rowUids;     // UID per CSV row (same index)
int curIndex = 0;

/* =======================
   NFC / workflow state
   ======================= */
enum State { IDLE, READY, WAITING_FOR_TAG, TAG_READ, SENDING, SENT, ERROR_STATE };
volatile State state = IDLE;

bool   scanArmed = false;            // true when waiting for an NFC tag
String nfcStatus = "Idle";

/* =========================================================
   Hard-coded ESP-NOW peers
   These are STA MAC addresses of ESP-B boards
   ========================================================= */
const char* HARD_CODED_MACS[MAX_PEERS] = {
  "38:18:2B:A7:7A:F4",
  "38:18:2B:A7:6D:6C",
  "38:18:2B:A7:9C:80",
  "38:18:2B:A7:9B:68",
  "38:18:2B:A7:86:4C"
};

/* =========================================================
   ESP-NOW peer tracking
   lastAttempt / lastSuccess are used to infer connectivity
   ========================================================= */
struct Peer {
  uint8_t mac[6]{};
  bool valid = false;
  unsigned long lastAttempt = 0;
  unsigned long lastSuccess = 0;

  String macStr() const {
    char b[18];
    sprintf(b, "%02X:%02X:%02X:%02X:%02X:%02X",
            mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    return String(b);
  }
};

Peer peers[MAX_PEERS];
volatile int lastSendPeer = -1;
unsigned long lastPingAt  = 0;
unsigned long tickAt      = 0;

/* =========================================================
   Convert RC522 UID bytes → readable hex string
   Example: "04:A1:BC:2F"
   ========================================================= */
static String uidToHexString(byte* buffer, byte len) {
  String s;
  s.reserve(len * 3);
  for (byte i = 0; i < len; i++) {
    if (buffer[i] < 0x10) s += "0";
    s += String(buffer[i], HEX);
    if (i + 1 < len) s += ":";
  }
  s.toUpperCase();
  return s;
}

/* =========================================================
   Convert MAC string → byte array
   Used to initialise ESP-NOW peers
   ========================================================= */
static bool macStringToBytes(const String& mac, uint8_t* out) {
  int idx = 0;
  int start = 0;

  for (int i = 0; i <= (int)mac.length(); i++) {
    if (i == (int)mac.length() || mac[i] == ':') {
      String part = mac.substring(start, i);
      part.trim();
      out[idx++] = (uint8_t)strtoul(part.c_str(), nullptr, 16);
      start = i + 1;
      if (idx >= 6) break;
    }
  }
  return idx == 6;
}

/* =========================================================
   Helper: detect uninitialised MAC
   ========================================================= */
static bool isZeroMac(const uint8_t* m) {
  for (int i = 0; i < 6; i++) {
    if (m[i] != 0) return false;
  }
  return true;
}

/* =========================================================
   Audible feedback when tag is read
   ========================================================= */
static void beep() {
  digitalWrite(BUZZER_PIN, HIGH);
  delay(100);
  digitalWrite(BUZZER_PIN, LOW);
}

/* =========================================================
   Escape strings for JSON output
   Prevents broken JSON when CSV contains quotes/newlines
   ========================================================= */
static String jsonEscape(String s) {
  s.replace("\\", "\\\\");
  s.replace("\"", "\\\"");
  s.replace("\r", " ");
  s.replace("\n", " ");
  return s;
}

/* =========================================================
   Append UID → patient mapping to SPIFFS
   This acts as a permanent audit trail
   ========================================================= */
static void appendMapping(const String& uid, int index0, const PatientRow& row) {
  File f = SPIFFS.open(MAPPING_PATH, FILE_APPEND);
  if (!f) return;

  String line = row.nric + "," + row.bedWard + "," +
                row.starch + "," + row.veg + "," +
                row.meat + "," + row.fruit + "," +
                row.drink + "," + row.remarks;

  line.replace("\n", " ");
  f.print(uid + "|" + String(index0) + "|" + line + "\n");
  f.close();
}

/* =========================================================
   CSV parsing
   Assumptions:
   - CSV is simple (no quoted commas)
   - First row is header
   - Minimum 9 columns
   ========================================================= */
static void splitCsvLine(const String& line, std::vector<String>& cols) {
  cols.clear();
  int start = 0;

  while (true) {
    int comma = line.indexOf(',', start);
    if (comma < 0) {
      String piece = line.substring(start);
      piece.trim();
      cols.push_back(piece);
      break;
    }
    String piece = line.substring(start, comma);
    piece.trim();
    cols.push_back(piece);
    start = comma + 1;
  }

  // Ensure column safety
  while (cols.size() < 9) cols.push_back("");
}

static void parseCSV() {
  patients.clear();
  rowUids.clear();
  curIndex = 0;

  if (!SPIFFS.exists(CSV_PATH)) {
    state = IDLE;
    return;
  }

  File f = SPIFFS.open(CSV_PATH, FILE_READ);
  if (!f) {
    state = IDLE;
    return;
  }

  int rowNum = 0;
  while (f.available()) {
    String line = f.readStringUntil('\n');
    line.trim();
    rowNum++;

    if (rowNum == 1 || line.isEmpty()) continue;

    std::vector<String> cols;
    splitCsvLine(line, cols);

    PatientRow pr;
    pr.nric    = cols[1];
    pr.bedWard = cols[2];
    pr.starch  = cols[3];
    pr.veg     = cols[4];
    pr.meat    = cols[5];
    pr.fruit   = cols[6];
    pr.drink   = cols[7];
    pr.remarks = cols[8];

    patients.push_back(pr);
    rowUids.push_back("");

    if (patients.size() >= MAX_ITEMS) break;
  }

  f.close();
  state = patients.empty() ? IDLE : READY;

  Serial.printf("Parsed %d rows from CSV\n", (int)patients.size());
}

/* =========================================================
   ESP-NOW callbacks
   ========================================================= */
void onSend(const wifi_tx_info_t*, esp_now_send_status_t status) {
  if (lastSendPeer >= 0 && lastSendPeer < MAX_PEERS && peers[lastSendPeer].valid) {
    peers[lastSendPeer].lastAttempt = millis();
    if (status == ESP_NOW_SEND_SUCCESS) {
      peers[lastSendPeer].lastSuccess = millis();
    }
  }
  lastSendPeer = -1;
}

void onRecv(const esp_now_recv_info_t* info, const uint8_t* data, int len) {
  if (!info || !data || len <= 0) return;

  String s;
  for (int i = 0; i < len; i++) s += (char)data[i];

  // PONG response updates peer health
  if (!s.startsWith("PONG|")) return;

  for (int i = 0; i < MAX_PEERS; i++) {
    if (!peers[i].valid) continue;
    bool match = true;
    for (int b = 0; b < 6; b++) {
      if (peers[i].mac[b] != info->src_addr[b]) {
        match = false;
        break;
      }
    }
    if (match) {
      peers[i].lastSuccess = millis();
      break;
    }
  }
}

/* =========================================================
   ESP-NOW transmit helpers
   Payload is capped at ~240 bytes to stay safe
   ========================================================= */
static void sendToPeer(int slot, const String& payload) {
  if (slot < 0 || slot >= MAX_PEERS || !peers[slot].valid) return;

  String out = payload;
  if (out.length() > 240) out = out.substring(0, 240);

  lastSendPeer = slot;
  peers[slot].lastAttempt = millis();

  esp_now_send(peers[slot].mac, (const uint8_t*)out.c_str(), out.length());
}

static void sendDataToAll(const String& uid, const PatientRow& row) {
  String payload = uid + "|" +
                   row.nric + "," + row.bedWard + "," +
                   row.starch + "," + row.veg + "," +
                   row.meat + "," + row.fruit + "," +
                   row.drink + "," + row.remarks;

  for (int i = 0; i < MAX_PEERS; i++) {
    if (peers[i].valid) sendToPeer(i, payload);
  }
}

static void pingAll() {
  String payload = "PING|" + String(millis());
  for (int i = 0; i < MAX_PEERS; i++) {
    if (peers[i].valid) sendToPeer(i, payload);
  }
}

/* =========================================================
   Setup & main loop
   ========================================================= */
void setup() {
  Serial.begin(115200);
  SPIFFS.begin(true);

  if (SPIFFS.exists(CSV_PATH)) SPIFFS.remove(CSV_PATH);
  if (SPIFFS.exists(MAPPING_PATH)) SPIFFS.remove(MAPPING_PATH);

  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);

  SPI.begin();
  mfrc522.PCD_Init();

  WiFi.mode(WIFI_AP_STA);
  WiFi.softAP(AP_SSID, AP_PWD, AP_CHANNEL);
  esp_wifi_set_channel(AP_CHANNEL, WIFI_SECOND_CHAN_NONE);
  WiFi.setSleep(false);

  esp_now_init();
  esp_now_register_send_cb(onSend);
  esp_now_register_recv_cb(onRecv);

  for (int i = 0; i < MAX_PEERS; i++) {
    uint8_t macb[6] = {0};
    String s = HARD_CODED_MACS[i];
    s.trim(); s.toUpperCase();

    peers[i].valid = macStringToBytes(s, macb) && !isZeroMac(macb);
    memcpy(peers[i].mac, macb, 6);

    if (peers[i].valid && !esp_now_is_peer_exist(peers[i].mac)) {
      esp_now_peer_info_t p = {};
      memcpy(p.peer_addr, peers[i].mac, 6);
      p.channel = AP_CHANNEL;
      p.ifidx   = WIFI_IF_STA;
      esp_now_add_peer(&p);
    }
  }

  server.begin();
}

void loop() {
  server.handleClient();

  if (millis() - lastPingAt > 5000) {
    lastPingAt = millis();
    pingAll();
  }

  if (!scanArmed) return;

  // NFC state machine:
  // 1. Wait for tag
  // 2. Read UID
  // 3. Bind UID → CSV row
  // 4. Send data
  if (mfrc522.PICC_IsNewCardPresent() &&
      mfrc522.PICC_ReadCardSerial()) {

    String uid = uidToHexString(
      mfrc522.uid.uidByte,
      mfrc522.uid.size
    );

    beep();
    rowUids[curIndex] = uid;
    appendMapping(uid, curIndex, patients[curIndex]);
    sendDataToAll(uid, patients[curIndex]);

    mfrc522.PICC_HaltA();
    mfrc522.PCD_StopCrypto1();

    curIndex++;

    if (curIndex >= (int)patients.size()) {
      scanArmed = false;
      state = ERROR_STATE;
    } else {
      delay(2000); // cooldown
    }
  }
}
